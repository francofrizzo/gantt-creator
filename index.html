<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gantt Creator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* custom scrollbar for the gantt area */
    .gantt-scroll::-webkit-scrollbar { height: 10px; width: 10px; }
    .gantt-scroll::-webkit-scrollbar-track { background: #1e293b; }
    .gantt-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 5px; }
    .gantt-scroll::-webkit-scrollbar-thumb:hover { background: #64748b; }
    textarea { font-family: 'SF Mono', 'Fira Code', 'Fira Mono', 'Roboto Mono', monospace !important; }
    .task-block { cursor: grab; transition: filter 0.1s; }
    .task-block:hover { filter: brightness(1.15); }
    .task-block.dragging { cursor: grabbing; filter: brightness(1.25); opacity: 0.9; }
    .task-block.error { animation: shake 0.4s ease-in-out; }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    .dep-arrow { pointer-events: none; }
    .violation-line { stroke: #ef4444; stroke-dasharray: 6 3; }
    .now-line { pointer-events: none; }
    .tooltip {
      position: fixed; background: #1e293b; color: #e2e8f0; padding: 6px 10px;
      border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 9999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); border: 1px solid #334155;
      white-space: nowrap;
    }
    .context-menu {
      position: fixed; background: #1e293b; color: #e2e8f0; padding: 4px 0;
      border-radius: 6px; font-size: 12px; z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 1px solid #334155;
      min-width: 120px;
    }
    .context-menu-item {
      padding: 6px 12px; cursor: pointer; transition: background 0.1s;
    }
    .context-menu-item:hover {
      background: #334155;
    }
    .context-menu-item.active {
      background: #475569;
    }
    /* Style time inputs for dark theme */
    input[type="time"] {
      color: #e2e8f0;
    }
    input[type="time"]::-webkit-calendar-picker-indicator {
      filter: invert(1);
      cursor: pointer;
    }
    input[type="time"]::-webkit-datetime-edit-text {
      color: #e2e8f0;
    }
    input[type="time"]::-webkit-datetime-edit-hour-field,
    input[type="time"]::-webkit-datetime-edit-minute-field {
      color: #e2e8f0;
    }
  </style>
</head>
<body class="bg-slate-900 text-slate-200 h-screen flex flex-col overflow-hidden">
  <!-- Top bar -->
  <header class="flex items-center justify-between px-4 py-2 bg-slate-800 border-b border-slate-700 shrink-0">
    <h1 class="text-lg font-semibold tracking-tight text-white">Gantt Creator</h1>
    <div class="flex items-center gap-2 text-xs text-slate-400">
      <span class="hidden sm:inline">Hold <kbd class="px-1.5 py-0.5 bg-slate-700 rounded text-slate-300 font-mono">Shift</kbd> for 1-min snap</span>
      <span class="hidden sm:inline">·</span>
      <span class="hidden sm:inline">Hold <kbd class="px-1.5 py-0.5 bg-slate-700 rounded text-slate-300 font-mono">⌘</kbd> to drag with dependencies</span>
      <span class="hidden sm:inline">·</span>
      <span id="snap-indicator" class="font-mono text-slate-300">Snap: 5 min</span>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden">
    <!-- Left panel -->
    <aside id="left-panel" class="w-[420px] shrink-0 flex flex-col border-r border-slate-700 bg-slate-850">
      <!-- Tabs -->
      <div class="flex border-b border-slate-700 bg-slate-800 h-10">
        <button class="tab-btn active flex-1 px-3 py-2 text-sm font-medium" data-tab="input">Input</button>
        <button class="tab-btn flex-1 px-3 py-2 text-sm font-medium" data-tab="help">Format &amp; Help</button>
      </div>

      <!-- Input tab -->
      <div id="tab-input" class="tab-content flex flex-col flex-1 overflow-hidden">
        <!-- Time range -->
        <div class="px-3 pt-3 pb-1">
          <label class="block text-xs font-medium text-slate-400 mb-1">Time Range</label>
          <div class="flex gap-2">
            <input id="start-time" type="time" value="09:00" class="flex-1 bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500" />
            <span class="self-center text-slate-500">→</span>
            <input id="end-time" type="time" value="14:00" class="flex-1 bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500" />
          </div>
        </div>

        <!-- Lanes -->
        <div class="px-3 pt-2 pb-1">
          <label class="block text-xs font-medium text-slate-400 mb-1">Lanes <span class="text-slate-500">(one per line, use Name: count for multiple)</span></label>
          <textarea id="lanes-input" rows="4" class="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 resize-none" placeholder="Person: 2&#10;Oven&#10;Stove">Person: 2
Oven</textarea>
        </div>

        <!-- Tasks -->
        <div class="px-3 pt-2 pb-1 flex flex-col flex-1 overflow-hidden">
          <label class="block text-xs font-medium text-slate-400 mb-1">Tasks <span class="text-slate-500">(one per line — see Help tab for format)</span></label>
          <textarea id="tasks-input" class="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 resize-none flex-1" placeholder="Chop vegetables | 15m | Person | #3b82f6&#10;Boil water | 10m | Person | #ef4444&#10;Cook pasta | 20m | Person | #f59e0b | after Boil water">Chop vegetables | 15m | Person | #3b82f6
Boil water | 10m | Person | #ef4444
Season chicken | 10m | Person | #a855f7 | after Chop vegetables
Cook pasta | 20m | Person | #f59e0b | after Boil water
Bake chicken | 45m | Oven | #a855f7 | after Season chicken
Plate meal | 10m | Person*2, Oven | #10b981 | after Cook pasta, Bake chicken
Music playing | 60m | Person(P) | #6b7280</textarea>
        </div>

        <!-- Parse errors -->
        <div id="parse-errors" class="px-3 hidden">
          <div class="bg-red-950/60 border border-red-800/50 rounded px-3 py-2 text-xs text-red-300 space-y-0.5 max-h-28 overflow-auto"></div>
        </div>

        <!-- Actions -->
        <div class="px-3 pt-2 pb-4 flex gap-2 shrink-0">
          <button id="btn-render" class="bg-blue-600 hover:bg-blue-500 text-white text-sm font-medium py-2 px-2 rounded transition-colors hidden flex-1" title="Auto-schedule and render tasks">
            Render
          </button>
          <button id="btn-import" class="bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm font-medium py-2 px-2 rounded transition-colors flex-1" title="Import .gantt file">
            Import
          </button>
          <div class="relative flex-1">
            <button id="btn-export" class="bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm font-medium py-2 px-2 rounded transition-colors w-full" title="Export tasks">
              Export
            </button>
            <div id="export-menu" class="context-menu hidden" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 4px;">
              <div class="context-menu-item" id="export-copy">Copy to clipboard</div>
              <div class="context-menu-item" id="export-save">Save .gantt file</div>
            </div>
          </div>

          <button id="btn-copy-prompt" class="bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm font-medium py-2 px-2 rounded transition-colors flex-1" title="Copy LLM prompt for generating input">
            LLM Prompt
          </button>
        </div>
        <input type="file" id="file-input" accept=".gantt" style="display: none;" />
      </div>

      <!-- Help tab -->
      <div id="tab-help" class="tab-content hidden flex-1 overflow-auto px-4 py-3 text-sm text-slate-300 leading-relaxed">
        <h3 class="font-semibold text-white mb-2">Lane Format</h3>
        <pre class="bg-slate-800 rounded p-3 text-xs mb-3 overflow-x-auto">Name: count</pre>
        <ul class="space-y-1 mb-4 text-xs text-slate-400">
          <li><strong class="text-slate-200">Name</strong> — lane group name (e.g. <code>Person</code>, <code>Oven</code>)</li>
          <li><strong class="text-slate-200">Count</strong> — number of sub-lanes (optional, defaults to 1)</li>
          <li>Examples: <code>Person: 2</code> creates "Person 1" and "Person 2"; <code>Oven</code> creates just "Oven"</li>
        </ul>
        <h3 class="font-semibold text-white mb-2">Task Format</h3>
        <pre class="bg-slate-800 rounded p-3 text-xs mb-3 overflow-x-auto">Name | Duration | Lane(s) | Color | Dependencies | @Start</pre>
        <ul class="space-y-1 mb-4 text-xs text-slate-400">
          <li><strong class="text-slate-200">Name</strong> — unique task name</li>
          <li><strong class="text-slate-200">Duration</strong> — e.g. <code>15m</code>, <code>1h</code>, <code>1h30m</code>, <code>90m</code></li>
          <li><strong class="text-slate-200">Lane(s)</strong> — comma-separated lane group names with optional quantities (e.g. <code>Person</code>, <code>Person*2</code>, <code>Person, Oven*2</code>). Use <code>*count</code> to require multiple sub-lanes of the same group. Use <code>Person#1</code> to pin to a specific sub-lane. Append <code>(P)</code> to mark a lane as passive (e.g. <code>Person(P)</code>, <code>Person#1(P)</code>).</li>
          <li><strong class="text-slate-200">Color</strong> — hex color like <code>#3b82f6</code> (optional, defaults to blue)</li>
          <li><strong class="text-slate-200">Dependencies</strong> — <code>after Task A, Task B</code> (optional)</li>
          <li><strong class="text-slate-200">Start time</strong> — <code>@08:30</code> pins the task to a specific time (optional). Use <em>Copy Tasks</em> to export after dragging.</li>
          <li><strong class="text-slate-200">Passive</strong> — append <code>(P)</code> to a lane name to mark the task as passive on that lane (e.g. <code>Person(P)</code>). Passive lane assignments are tracked visually but won't block scheduling of other tasks on those lanes. A task can be active on some lanes and passive on others.</li>
        </ul>
        <h3 class="font-semibold text-white mb-2">Interaction</h3>
        <ul class="space-y-1 text-xs text-slate-400">
          <li>Drag blocks horizontally to reschedule. Default snap: <strong class="text-slate-200">5 minutes</strong>.</li>
          <li>Hold <kbd class="px-1 py-0.5 bg-slate-700 rounded text-slate-300">Shift</kbd> while dragging for <strong class="text-slate-200">1-minute</strong> snap.</li>
          <li><strong class="text-slate-200">Right-click</strong> a task block to move it between sub-lanes of the same group (only works for single-lane tasks).</li>
          <li>Dependency violations are shown with red dashed lines.</li>
          <li>Hover a block for timing details.</li>
        </ul>
      </div>
    </aside>

    <!-- Right panel: Gantt -->
    <main class="flex-1 flex flex-col overflow-hidden bg-slate-900">
      <!-- Gantt header with current time -->
      <div class="flex items-center justify-between px-4 py-2 bg-slate-800 border-b border-slate-700 shrink-0 h-10">
        <span class="text-sm text-slate-400" id="gantt-status">Define lanes &amp; tasks, then hit Render.</span>
        <div class="flex items-center gap-3">
          <label class="flex items-center gap-1.5 text-xs text-slate-400">
            <input type="checkbox" id="show-now" class="rounded bg-slate-700 border-slate-600" checked />
            Show current time
          </label>
          <label class="flex items-center gap-1.5 text-xs text-slate-400">
            <input type="checkbox" id="show-deps" class="rounded bg-slate-700 border-slate-600" checked />
            Show dependencies
          </label>
        </div>
      </div>
      <div id="gantt-container" class="flex-1 overflow-auto gantt-scroll relative">
        <!-- populated by JS -->
        <div id="gantt-empty" class="flex items-center justify-center h-full text-slate-600 text-sm select-none">
          Your Gantt chart will appear here.
        </div>
      </div>
    </main>
  </div>

  <!-- Tooltip -->
  <div id="tooltip" class="tooltip hidden"></div>
  
  <!-- Context Menu -->
  <div id="context-menu" class="context-menu hidden"></div>

  <script>
    // ── State ──
    let laneGroups = [];  // [{ name: "Person", count: 2 }, ...]
    let lanes = [];       // ["Person 1", "Person 2", "Oven"] - derived from groups
    let tasks = [];
    let startMinutes = 0;
    let endMinutes = 0;
    let prevStartMinutes = null;
    let pixelsPerMinute = 3;
    const LANE_LABEL_WIDTH = 140;
    const HEADER_HEIGHT = 36;
    const BLOCK_PADDING = 10;
    let shiftHeld = false;
    let metaHeld = false;
    let dragState = null;
    let panState = null;
    let suppressSync = false;  // Prevent sync loop when updating textarea programmatically
    let dslChangeTimeout = null;  // Debounce timer

    // ── DOM refs ──
    const lanesInput = document.getElementById('lanes-input');
    const tasksInput = document.getElementById('tasks-input');
    const startTimeInput = document.getElementById('start-time');
    const endTimeInput = document.getElementById('end-time');
    const ganttContainer = document.getElementById('gantt-container');
    const ganttEmpty = document.getElementById('gantt-empty');
    const ganttStatus = document.getElementById('gantt-status');
    const snapIndicator = document.getElementById('snap-indicator');
    const tooltipEl = document.getElementById('tooltip');
    const contextMenuEl = document.getElementById('context-menu');
    const showNowCheck = document.getElementById('show-now');
    const showDepsCheck = document.getElementById('show-deps');

    // ── Tabs ──
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active', 'text-white', 'border-b-2', 'border-blue-500'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        btn.classList.add('active', 'text-white', 'border-b-2', 'border-blue-500');
        document.getElementById('tab-' + btn.dataset.tab).classList.remove('hidden');
      });
    });
    document.querySelector('.tab-btn[data-tab="input"]').click();

    // ── Live DSL-to-Gantt sync (debounced) ──
    function debouncedDslChange() {
      if (suppressSync) return;
      if (dslChangeTimeout) clearTimeout(dslChangeTimeout);
      dslChangeTimeout = setTimeout(() => {
        onDslChange();
      }, 300);
    }
    lanesInput.addEventListener('input', debouncedDslChange);
    tasksInput.addEventListener('input', debouncedDslChange);
    startTimeInput.addEventListener('input', debouncedDslChange);
    endTimeInput.addEventListener('input', debouncedDslChange);

    // ── Modifier key tracking ──
    function updateSnapIndicator() {
      let text = shiftHeld ? 'Snap: 1 min' : 'Snap: 5 min';
      if (metaHeld) text += ' · Group';
      snapIndicator.textContent = text;
    }
    window.addEventListener('keydown', e => {
      if (e.key === 'Shift') { shiftHeld = true; updateSnapIndicator(); }
      if (e.key === 'Meta') { metaHeld = true; updateSnapIndicator(); }
    });
    window.addEventListener('keyup', e => {
      if (e.key === 'Shift') { shiftHeld = false; updateSnapIndicator(); }
      if (e.key === 'Meta') { metaHeld = false; updateSnapIndicator(); }
    });

    // ── Parsing ──
    function timeToMinutes(str) {
      const [h, m] = str.split(':').map(Number);
      return h * 60 + m;
    }

    function minutesToTime(m) {
      const h = Math.floor(m / 60);
      const min = m % 60;
      return `${String(h).padStart(2, '0')}:${String(min).padStart(2, '0')}`;
    }

    function parseDuration(str) {
      str = str.trim().toLowerCase();
      let total = 0;
      const hMatch = str.match(/(\d+)\s*h/);
      const mMatch = str.match(/(\d+)\s*m/);
      if (hMatch) total += parseInt(hMatch[1]) * 60;
      if (mMatch) total += parseInt(mMatch[1]);
      if (!hMatch && !mMatch) {
        const n = parseInt(str);
        if (!isNaN(n)) total = n;
      }
      return total;
    }

    function formatDuration(min) {
      if (min < 60) return `${min}m`;
      const h = Math.floor(min / 60);
      const m = min % 60;
      return m > 0 ? `${h}h${m}m` : `${h}h`;
    }

    function parseLaneGroups() {
      const lines = lanesInput.value.split('\n').map(l => l.trim()).filter(Boolean);
      const groups = [];
      const flatLanes = [];
      
      for (const line of lines) {
        const match = line.match(/^(.+?)(?::\s*(\d+))?$/);
        if (!match) continue;
        const name = match[1].trim();
        const count = match[2] ? parseInt(match[2], 10) : 1;
        if (count < 1) continue;
        
        groups.push({ name, count });
        
        // Expand to sub-lanes
        if (count === 1) {
          flatLanes.push(name);
        } else {
          for (let i = 1; i <= count; i++) {
            flatLanes.push(`${name} ${i}`);
          }
        }
      }
      
      return { groups, flatLanes };
    }

    function parseTasks(laneList) {
      const lines = tasksInput.value.split('\n').map(l => l.trim()).filter(Boolean);
      const result = [];
      const errors = [];
      const seenNames = new Set();
      const groupNames = laneGroups.map(g => g.name);

      for (let lineNum = 0; lineNum < lines.length; lineNum++) {
        const line = lines[lineNum];
        const parts = line.split('|').map(s => s.trim());
        if (parts.length < 3) {
          errors.push(`Line ${lineNum + 1}: expected at least 3 fields (Name | Duration | Lane), got ${parts.length}`);
          continue;
        }
        const name = parts[0];
        if (!name) {
          errors.push(`Line ${lineNum + 1}: task name is empty`);
          continue;
        }
        if (seenNames.has(name)) {
          errors.push(`Line ${lineNum + 1}: duplicate task name "${name}"`);
        }
        seenNames.add(name);

        const duration = parseDuration(parts[1]);
        if (duration <= 0) {
          errors.push(`Line ${lineNum + 1} ("${name}"): invalid duration "${parts[1]}"`);
          continue;
        }
        
        // Parse lane requirements: "Person", "Person*2", "Person#1", "Person(P)", "Person#1(P)", "Person, Oven*2"
        const laneSpecs = parts[2].split(',').map(l => l.trim()).filter(Boolean);
        const laneReqs = []; // [{ groupName, count, pinnedLanes?, passive }]
        let laneError = false;
        for (let spec of laneSpecs) {
          // Check for (P) passive suffix (case-insensitive)
          let isPassive = false;
          const passiveMatch = spec.match(/^(.+?)\s*\([Pp]\)$/);
          if (passiveMatch) {
            isPassive = true;
            spec = passiveMatch[1];
          }
          // Try formats: "Group#n" (pin to sub-lane), "Group*count", "Group: count", or just "Group"
          const pinMatch = spec.match(/^(.+?)#(\d+)$/);
          const starMatch = spec.match(/^(.+?)\*(\d+)$/);
          const colonMatch = spec.match(/^(.+?):\s*(\d+)$/);
          let gName, gCount, pinnedLanes = null;
          if (pinMatch) {
            gName = pinMatch[1].trim();
            gCount = 1;
            const subIdx = parseInt(pinMatch[2], 10);
            const group = laneGroups.find(g => g.name === gName);
            if (!group) {
              errors.push(`Line ${lineNum + 1} ("${name}"): unknown lane "${gName}"`);
              laneError = true;
            } else if (group.count === 1) {
              // Group has count 1 — sub-lane is just the group name, #N is ignored
              pinnedLanes = [gName];
            } else if (subIdx < 1 || subIdx > group.count) {
              errors.push(`Line ${lineNum + 1} ("${name}"): "${gName}#${subIdx}" is out of range (1–${group.count})`);
              laneError = true;
            } else {
              pinnedLanes = [`${gName} ${subIdx}`];
            }
          } else if (starMatch) {
            gName = starMatch[1].trim();
            gCount = parseInt(starMatch[2], 10);
          } else if (colonMatch) {
            gName = colonMatch[1].trim();
            gCount = parseInt(colonMatch[2], 10);
          } else {
            gName = spec;
            gCount = 1;
          }
          if (!pinnedLanes && !laneError && !groupNames.includes(gName)) {
            errors.push(`Line ${lineNum + 1} ("${name}"): unknown lane "${gName}"`);
            laneError = true;
          }
          laneReqs.push({ groupName: gName, count: gCount, pinnedLanes, passive: isPassive });
        }
        if (laneError) continue;
        
        const color = (parts[3] && parts[3].startsWith('#')) ? parts[3] : '#3b82f6';
        // Search optional fields only from index 4 onward (after name, duration, lanes, color)
        const optionalParts = parts.slice(4);
        let deps = [];
        const depPart = optionalParts.find(p => p.toLowerCase().startsWith('after '));
        if (depPart) {
          deps = depPart.replace(/^after\s+/i, '').split(',').map(d => d.trim()).filter(Boolean);
        }
        // Optional pinned start time: @HH:MM
        let pinnedStart = null;
        const timePart = optionalParts.find(p => /^@\d{1,2}:\d{2}$/.test(p));
        if (timePart) {
          pinnedStart = timeToMinutes(timePart.slice(1));
        }
        result.push({ name, duration, laneReqs, color, deps, startMin: pinnedStart, pinned: pinnedStart !== null, assignedLanes: null });
      }

      // Validate dependencies reference existing tasks
      const taskNames = new Set(result.map(t => t.name));
      for (const task of result) {
        for (const dep of task.deps) {
          if (!taskNames.has(dep)) {
            errors.push(`Task "${task.name}": dependency "${dep}" not found`);
          }
        }
      }

      return { tasks: result, errors };
    }

    // ── Export current task state back to text (with @start times and assigned lanes) ──
    function subLaneToSpec(subLane) {
      // Convert a flat sub-lane name back to pin syntax: "Person 2" -> "Person#2", "Oven" -> "Oven"
      for (const group of laneGroups) {
        if (group.count === 1 && subLane === group.name) return group.name;
        if (group.count > 1 && subLane.startsWith(group.name + ' ')) {
          const suffix = subLane.slice(group.name.length + 1);
          return `${group.name}#${suffix}`;
        }
      }
      return subLane;
    }

    function exportTasks() {
      const lines = [];
      for (const task of tasks) {
        // Use actual assigned lanes if available, otherwise fall back to laneReqs
        let laneSpecs;
        if (task.assignedLanes && task.assignedLanes.length > 0) {
          laneSpecs = task.assignedLanes.map(sl => {
            const spec = subLaneToSpec(sl);
            return isPassiveOnLane(task, sl) ? `${spec}(P)` : spec;
          });
        } else {
          laneSpecs = task.laneReqs.map(req => {
            const suffix = req.passive ? '(P)' : '';
            if (req.pinnedLanes) return req.pinnedLanes.map(pl => subLaneToSpec(pl) + suffix);
            if (req.count === 1) return req.groupName + suffix;
            return `${req.groupName}*${req.count}${suffix}`;
          }).flat();
        }
        
        let line = `${task.name} | ${formatDuration(task.duration)} | ${laneSpecs.join(', ')} | ${task.color}`;
        if (task.deps.length) line += ` | after ${task.deps.join(', ')}`;
        if (task.startMin !== null) line += ` | @${minutesToTime(task.startMin)}`;
        lines.push(line);
      }
      return lines.join('\n');
    }

    // ── Helper: get sub-lanes for a group name ──
    function getSubLanesForGroup(groupName) {
      return lanes.filter(l => {
        if (l === groupName) return true; // count=1 case
        return l.startsWith(groupName + ' ');
      });
    }

    // ── Helper: check if a task is passive on a given sub-lane ──
    function isPassiveOnLane(task, subLaneName) {
      // Prefer exact pinned-lane match (handles Person#1(P), Person#2 correctly)
      for (const req of task.laneReqs) {
        if (req.pinnedLanes && req.pinnedLanes.includes(subLaneName)) return !!req.passive;
      }
      // Fall back to group-level match for unpinned requirements
      for (const req of task.laneReqs) {
        if (!req.pinnedLanes) {
          const subLanes = getSubLanesForGroup(req.groupName);
          if (subLanes.includes(subLaneName)) return !!req.passive;
        }
      }
      return false;
    }

    // ── Helper: check if all tasks are fully pinned (have @time and all lanes pinned) ──
    function isFullyPinned(parsedTasks) {
      if (parsedTasks.length === 0) return false;
      for (const task of parsedTasks) {
        // Must have a pinned start time
        if (!task.pinned || task.startMin === null) return false;
        // All lane requirements must be pinned (have pinnedLanes) or belong to count-1 groups
        for (const req of task.laneReqs) {
          if (!req.pinnedLanes) {
            // Check if this is a count-1 group (which is implicitly pinned)
            const group = laneGroups.find(g => g.name === req.groupName);
            if (!group || group.count > 1) return false;
          }
        }
      }
      return true;
    }

    // ── Sync Gantt state back to DSL textarea ──
    function syncGanttToDsl() {
      if (!tasks.length) return;
      suppressSync = true;
      const exported = exportTasks();
      tasksInput.value = exported;
      suppressSync = false;
    }

    // ── Handle DSL changes (debounced) ──
    function onDslChange() {
      const parsed = parseLaneGroups();
      laneGroups = parsed.groups;
      lanes = parsed.flatLanes;
      const parseResult = parseTasks(lanes);
      const parsedTasks = parseResult.tasks;
      showParseErrors(parseResult.errors);

      // If there are parse errors, don't render
      if (parseResult.errors.length > 0) {
        document.getElementById('btn-render').classList.add('hidden');
        return;
      }

      // Update time range
      const newStartMin = timeToMinutes(startTimeInput.value);
      endMinutes = timeToMinutes(endTimeInput.value);

      // Detect start time change → shift all pinned task times & end time
      const startTimeShifted = prevStartMinutes !== null && newStartMin !== prevStartMinutes;
      if (startTimeShifted) {
        const delta = newStartMin - prevStartMinutes;
        for (const task of parsedTasks) {
          if (task.startMin !== null) {
            task.startMin += delta;
          }
        }
        // Also shift end time to preserve window duration
        endMinutes += delta;
        endTimeInput.value = minutesToTime(endMinutes);
      }
      prevStartMinutes = newStartMin;
      startMinutes = newStartMin;
      if (endMinutes <= startMinutes) endMinutes = startMinutes + 360;

      // Check if fully pinned
      if (isFullyPinned(parsedTasks)) {
        // Fully pinned: render immediately without auto-scheduling
        tasks = parsedTasks;
        // Populate assignedLanes from pinnedLanes
        for (const task of tasks) {
          if (!task.assignedLanes) {
            task.assignedLanes = [];
            for (const req of task.laneReqs) {
              if (req.pinnedLanes) {
                task.assignedLanes.push(...req.pinnedLanes);
              } else {
                // Count-1 group: use the group name as the sub-lane
                const group = laneGroups.find(g => g.name === req.groupName);
                if (group && group.count === 1) {
                  task.assignedLanes.push(req.groupName);
                }
              }
            }
          }
        }
        const totalMinutes = endMinutes - startMinutes;
        const availableWidth = ganttContainer.clientWidth - LANE_LABEL_WIDTH - 20;
        pixelsPerMinute = Math.max(2, availableWidth / totalMinutes);
        drawGantt();
        if (startTimeShifted) syncGanttToDsl();  // Persist shifted times to DSL
        document.getElementById('btn-render').classList.add('hidden');
      } else {
        // Not fully pinned: show Render button, don't auto-render
        tasks = parsedTasks;
        document.getElementById('btn-render').classList.remove('hidden');
      }
    }

    // ── Auto-schedule ──
    function autoSchedule() {
      const scheduled = new Set();
      const laneEnd = {};  // sub-lane -> earliest free minute
      lanes.forEach(l => laneEnd[l] = startMinutes);

      // Pre-register pinned tasks (they keep their start time, but need assignedLanes)
      for (const task of tasks) {
        if (task.pinned && task.startMin !== null) {
          scheduled.add(task.name);
          // Assign to sub-lanes if not already assigned
          if (!task.assignedLanes) {
            task.assignedLanes = [];
            for (const req of task.laneReqs) {
              // If this requirement has pinned sub-lanes, use them directly
              if (req.pinnedLanes) {
                for (const pl of req.pinnedLanes) {
                  task.assignedLanes.push(pl);
                  if (!req.passive) {
                    laneEnd[pl] = Math.max(laneEnd[pl] || startMinutes, task.startMin + task.duration);
                  }
                }
                continue;
              }
              const subLanes = getSubLanesForGroup(req.groupName);
              if (subLanes.length === 0) continue;
              
              // Need to pick 'count' sub-lanes
              const needed = Math.min(req.count, subLanes.length);
              const selected = [];
              
              // Sort sub-lanes by availability (earliest end time first)
              const available = subLanes.map(sl => ({
                lane: sl,
                end: laneEnd[sl] || startMinutes
              })).sort((a, b) => a.end - b.end);
              
              // Pick the first 'needed' sub-lanes
              for (let i = 0; i < needed; i++) {
                const chosen = available[i];
                selected.push(chosen.lane);
                // Only update laneEnd for non-passive requirements
                if (!req.passive) {
                  laneEnd[chosen.lane] = Math.max(chosen.end, task.startMin + task.duration);
                }
              }
              
              task.assignedLanes.push(...selected);
            }
          } else {
            // Already assigned, just update laneEnd (only for non-passive lanes)
            for (const subLane of task.assignedLanes) {
              if (!isPassiveOnLane(task, subLane)) {
                laneEnd[subLane] = Math.max(laneEnd[subLane] || startMinutes, task.startMin + task.duration);
              }
            }
          }
        }
      }

      // Topological order via repeated passes for non-pinned tasks
      let remaining = tasks.filter(t => !t.pinned || t.startMin === null);
      let passes = 0;
      while (remaining.length > 0 && passes < 1000) {
        passes++;
        const next = [];
        for (const task of remaining) {
          const depsReady = task.deps.every(d => scheduled.has(d));
          if (!depsReady) { next.push(task); continue; }

          // Earliest start based on deps
          let earliest = startMinutes;
          for (const d of task.deps) {
            const depTask = tasks.find(t => t.name === d);
            if (depTask && depTask.startMin !== null) {
              earliest = Math.max(earliest, depTask.startMin + depTask.duration);
            }
          }
          
          // Assign to sub-lanes: pick best sub-lanes per requirement
          if (!task.assignedLanes) {
            task.assignedLanes = [];
            for (const req of task.laneReqs) {
              // If this requirement has pinned sub-lanes, use them directly
              if (req.pinnedLanes) {
                for (const pl of req.pinnedLanes) {
                  task.assignedLanes.push(pl);
                  if (!req.passive) {
                    earliest = Math.max(earliest, laneEnd[pl] || startMinutes);
                  }
                }
                continue;
              }
              const subLanes = getSubLanesForGroup(req.groupName);
              if (subLanes.length === 0) continue;
              
              // Need to pick 'count' sub-lanes
              const needed = Math.min(req.count, subLanes.length);
              
              // Sort sub-lanes by availability (earliest end time first)
              const available = subLanes.map(sl => ({
                lane: sl,
                end: laneEnd[sl] || startMinutes
              })).sort((a, b) => a.end - b.end);
              
              // Pick the first 'needed' sub-lanes and track the latest end time
              // For passive requirements, ignore lane availability (they don't conflict)
              if (req.passive) {
                for (let i = 0; i < needed; i++) {
                  task.assignedLanes.push(available[i].lane);
                }
              } else {
                for (let i = 0; i < needed; i++) {
                  const chosen = available[i];
                  task.assignedLanes.push(chosen.lane);
                  earliest = Math.max(earliest, chosen.end);
                }
              }
            }
          } else {
            // Already assigned, check availability (only for non-passive lanes)
            for (const subLane of task.assignedLanes) {
              if (!isPassiveOnLane(task, subLane)) {
                earliest = Math.max(earliest, laneEnd[subLane] || startMinutes);
              }
            }
          }

          task.startMin = earliest;
          // Only update laneEnd for non-passive lanes
          for (const subLane of task.assignedLanes || []) {
            if (!isPassiveOnLane(task, subLane)) {
              laneEnd[subLane] = earliest + task.duration;
            }
          }
          scheduled.add(task.name);
        }
        remaining = next;
      }

      // Anything unresolved: place at start and assign to first available sub-lanes
      for (const t of tasks) {
        if (t.startMin === null) {
          t.startMin = startMinutes;
          if (!t.assignedLanes) {
            t.assignedLanes = [];
            for (const req of t.laneReqs) {
              const subLanes = getSubLanesForGroup(req.groupName);
              if (subLanes.length > 0) {
                t.assignedLanes.push(subLanes[0]);
              }
            }
          }
        }
      }
    }

    // ── Violation checking ──
    function getViolations() {
      const violations = [];
      // Dependency violations
      for (const task of tasks) {
        for (const depName of task.deps) {
          const dep = tasks.find(t => t.name === depName);
          if (!dep) continue;
          if (task.startMin < dep.startMin + dep.duration) {
            violations.push({ type: 'dependency', from: dep, to: task });
          }
        }
      }
      // Overlap violations: two non-passive tasks on the same sub-lane overlapping in time
      for (const subLane of lanes) {
        const laneTasks = tasks.filter(t =>
          !isPassiveOnLane(t, subLane) && t.startMin !== null && t.assignedLanes && t.assignedLanes.includes(subLane)
        );
        for (let i = 0; i < laneTasks.length; i++) {
          for (let j = i + 1; j < laneTasks.length; j++) {
            const a = laneTasks[i], b = laneTasks[j];
            if (a.startMin < b.startMin + b.duration && b.startMin < a.startMin + a.duration) {
              violations.push({ type: 'overlap', from: a, to: b, lane: subLane });
            }
          }
        }
      }
      return violations;
    }

    // ── Render ──
    function render() {
      const parsed = parseLaneGroups();
      laneGroups = parsed.groups;
      lanes = parsed.flatLanes;
      const parseResult = parseTasks(lanes);
      tasks = parseResult.tasks;
      showParseErrors(parseResult.errors);
      startMinutes = timeToMinutes(startTimeInput.value);
      endMinutes = timeToMinutes(endTimeInput.value);
      if (endMinutes <= startMinutes) endMinutes = startMinutes + 360;

      // Auto-schedule tasks that don't have a pinned start time
      if (tasks.some(t => t.startMin === null || !t.assignedLanes)) autoSchedule();

      const totalMinutes = endMinutes - startMinutes;
      // Calculate pixelsPerMinute to fit well
      const availableWidth = ganttContainer.clientWidth - LANE_LABEL_WIDTH - 20;
      pixelsPerMinute = Math.max(2, availableWidth / totalMinutes);

      drawGantt();
    }

    // ── Cascade layout: assign each task a sequence index per lane for a visual stagger ──
    const CASCADE_STEP = 5;        // pixels of vertical offset per successive task (reduced for subtlety)
    const BLOCK_HEIGHT = 34;       // height of each task block
    const PASSIVE_BAR_HEIGHT = 10; // height of passive task thin bars
    const PASSIVE_BAR_GAP = 3;    // gap between stacked passive bars

    function computeCascade() {
      // For each sub-lane, separate passive and non-passive tasks, then assign sequence indices.
      // Passive tasks get negative indices to float above, non-passive get 0, 1, 2, ...
      // taskCascade: Map<taskIdx, { subLaneName: sequenceIndex }>
      // laneCounts: { subLaneName: number of tasks in that sub-lane }
      const taskCascade = new Map();
      const laneCounts = {};

      for (const subLane of lanes) {
        const regularTasks = [];
        const passiveTasks = [];
        for (let ti = 0; ti < tasks.length; ti++) {
          const t = tasks[ti];
          if (t.startMin !== null && t.assignedLanes && t.assignedLanes.includes(subLane)) {
            if (isPassiveOnLane(t, subLane)) {
              passiveTasks.push({ ti, start: t.startMin });
            } else {
              regularTasks.push({ ti, start: t.startMin });
            }
          }
        }
        regularTasks.sort((a, b) => a.start - b.start);
        passiveTasks.sort((a, b) => a.start - b.start);

        // Regular tasks: sequence 0, 1, 2, ...
        for (let seq = 0; seq < regularTasks.length; seq++) {
          const ti = regularTasks[seq].ti;
          if (!taskCascade.has(ti)) taskCascade.set(ti, {});
          taskCascade.get(ti)[subLane] = seq;
        }
        
        // Passive tasks: sequence 0, 1, 2, ... (will be positioned at top of lane)
        for (let seq = 0; seq < passiveTasks.length; seq++) {
          const ti = passiveTasks[seq].ti;
          if (!taskCascade.has(ti)) taskCascade.set(ti, {});
          taskCascade.get(ti)[subLane] = seq; // Use positive indices, we'll handle positioning separately
        }
        
        laneCounts[subLane] = regularTasks.length + passiveTasks.length;
      }

      // Count passive tasks per lane for height calculation
      const passiveCounts = {};
      for (const subLane of lanes) {
        passiveCounts[subLane] = 0;
        for (let ti = 0; ti < tasks.length; ti++) {
          const t = tasks[ti];
          if (isPassiveOnLane(t, subLane) && t.startMin !== null && t.assignedLanes && t.assignedLanes.includes(subLane)) {
            passiveCounts[subLane]++;
          }
        }
      }

      return { taskCascade, laneCounts, passiveCounts };
    }

    function drawGantt() {
      ganttEmpty.classList.add('hidden');
      const totalMinutes = endMinutes - startMinutes;

      // Compute cascade layout
      const { taskCascade, laneCounts, passiveCounts } = computeCascade();

      // Compute per-lane heights and cumulative Y offsets
      const laneHeights = [];
      const laneYOffsets = [];
      let cumulativeY = 0;
      for (let i = 0; i < lanes.length; i++) {
        const subLane = lanes[i];
        const count = laneCounts[subLane] || 1;
        const passiveCount = passiveCounts[subLane] || 0;
        
        // Regular tasks height: block height + cascade offset for each additional task
        const regularCount = count - passiveCount;
        const regularHeight = BLOCK_HEIGHT + Math.max(0, regularCount - 1) * CASCADE_STEP;
        
        // Space needed for passive task thin bars above active tasks
        const passiveSpace = passiveCount > 0 
          ? passiveCount * PASSIVE_BAR_HEIGHT + (passiveCount - 1) * PASSIVE_BAR_GAP + 12
          : 0;
        
        // Total lane height = passive space + regular height + padding
        const h = passiveSpace + regularHeight + BLOCK_PADDING * 2;
        laneHeights.push(h);
        laneYOffsets.push(cumulativeY);
        cumulativeY += h;
      }

      const chartWidth = LANE_LABEL_WIDTH + totalMinutes * pixelsPerMinute + 20;
      const chartHeight = HEADER_HEIGHT + cumulativeY + 20;

      const violations = getViolations();
      const violationCount = violations.length;
      ganttStatus.textContent = tasks.length + ' tasks · ' + lanes.length + ' lanes' +
        (violationCount > 0 ? ` · ${violationCount} violation${violationCount > 1 ? 's' : ''}` : '');
      if (violationCount > 0) ganttStatus.classList.add('text-red-400');
      else ganttStatus.classList.remove('text-red-400');

      // Build SVG
      let svg = `<svg id="gantt-svg" width="${chartWidth}" height="${chartHeight}" xmlns="http://www.w3.org/2000/svg" style="min-width:${chartWidth}px">`;

      // Background
      svg += `<rect width="${chartWidth}" height="${chartHeight}" fill="#0f172a"/>`;

      // Header bar with first alternating color
      svg += `<rect x="0" y="0" width="${chartWidth}" height="${HEADER_HEIGHT}" fill="#1e293b"/>`;

      // Lane rows (variable height) - alternation starts after header (i=0 uses second color)
      for (let i = 0; i < lanes.length; i++) {
        const y = HEADER_HEIGHT + laneYOffsets[i];
        const h = laneHeights[i];
        svg += `<rect x="0" y="${y}" width="${chartWidth}" height="${h}" fill="${i % 2 === 0 ? '#0f172a' : '#1e293b'}"/>`;
        // Lane label (vertically centered)
        svg += `<text x="${LANE_LABEL_WIDTH - 10}" y="${y + h / 2 + 4}" fill="#cbd5e1" font-size="13" text-anchor="end" font-family="sans-serif">${escapeHtml(lanes[i])}</text>`;
        // Separator
        svg += `<line x1="0" y1="${y + h}" x2="${chartWidth}" y2="${y + h}" stroke="#1e293b" stroke-width="0.5"/>`;
      }

      // Time grid lines and labels (drawn after lanes so they appear on top)
      // Draw subtle half-hour lines first
      for (let m = 30; m < totalMinutes; m += 60) {
        const x = LANE_LABEL_WIDTH + m * pixelsPerMinute;
        svg += `<line x1="${x}" y1="${HEADER_HEIGHT}" x2="${x}" y2="${chartHeight}" stroke="#1a2332" stroke-width="0.5" opacity="0.5"/>`;
      }
      // Draw main grid lines (hours and other intervals)
      const step = totalMinutes <= 120 ? 15 : totalMinutes <= 360 ? 30 : 60;
      for (let m = 0; m <= totalMinutes; m += step) {
        const x = LANE_LABEL_WIDTH + m * pixelsPerMinute;
        const isMajor = m % 60 === 0;
        svg += `<line x1="${x}" y1="${HEADER_HEIGHT}" x2="${x}" y2="${chartHeight}" stroke="${isMajor ? '#334155' : '#1e293b'}" stroke-width="${isMajor ? 1 : 0.5}"/>`;
        svg += `<text x="${x}" y="${HEADER_HEIGHT - 8}" fill="#94a3b8" font-size="12" text-anchor="middle" font-family="monospace">${minutesToTime(startMinutes + m)}</text>`;
      }

      // Lane label separator
      svg += `<line x1="${LANE_LABEL_WIDTH}" y1="${HEADER_HEIGHT}" x2="${LANE_LABEL_WIDTH}" y2="${chartHeight}" stroke="#334155" stroke-width="1"/>`;

      // Helper: get the vertical center of a task block in a given sub-lane
      function taskBlockCenterY(taskIdx, subLaneName) {
        if (!subLaneName) return HEADER_HEIGHT;
        const laneIdx = lanes.indexOf(subLaneName);
        if (laneIdx === -1) return HEADER_HEIGHT;
        const task = tasks[taskIdx];
        const seq = (taskCascade.get(taskIdx) || {})[subLaneName] || 0;
        const passiveCount = passiveCounts[subLaneName] || 0;
        const passiveSpace = passiveCount > 0 
          ? passiveCount * PASSIVE_BAR_HEIGHT + (passiveCount - 1) * PASSIVE_BAR_GAP + 12
          : 0;
        const laneY = HEADER_HEIGHT + laneYOffsets[laneIdx] + BLOCK_PADDING + passiveSpace;
        // Passive tasks: thin bars at top of lane; regular tasks start after passive space
        if (task && isPassiveOnLane(task, subLaneName)) {
          const y = HEADER_HEIGHT + laneYOffsets[laneIdx] + BLOCK_PADDING + seq * (PASSIVE_BAR_HEIGHT + PASSIVE_BAR_GAP);
          return y + PASSIVE_BAR_HEIGHT / 2;
        }
        return laneY + seq * CASCADE_STEP + BLOCK_HEIGHT / 2;
      }

      // Dependency arrows (behind blocks) — with color gradients
      const arrowDefs = [];
      if (showDepsCheck.checked) {
        let arrowIdx = 0;
        for (let ti = 0; ti < tasks.length; ti++) {
          const task = tasks[ti];
          for (const depName of task.deps) {
            const depIdx = tasks.findIndex(t => t.name === depName);
            const dep = depIdx >= 0 ? tasks[depIdx] : null;
            if (!dep || dep.startMin === null || task.startMin === null) continue;
            const isViolation = task.startMin < dep.startMin + dep.duration;

            // Arrow from end of dep to start of task
            const fromX = LANE_LABEL_WIDTH + (dep.startMin - startMinutes + dep.duration) * pixelsPerMinute;
            const fromY = taskBlockCenterY(depIdx, dep.assignedLanes && dep.assignedLanes[0] ? dep.assignedLanes[0] : null);

            const toX = LANE_LABEL_WIDTH + (task.startMin - startMinutes) * pixelsPerMinute;
            const toY = taskBlockCenterY(ti, task.assignedLanes && task.assignedLanes[0] ? task.assignedLanes[0] : null);

            const dashArray = isViolation ? '6 3' : 'none';

            // Step routing: always arrives from the left
            const GAP = 12;
            const RADIUS = 6;
            const MIN_RUN = 20;

            // Same lane and adjacent: skip the arrow entirely
            const depPrimaryLane = dep.assignedLanes && dep.assignedLanes[0];
            const taskPrimaryLane = task.assignedLanes && task.assignedLanes[0];
            const sameLane = depPrimaryLane && taskPrimaryLane && depPrimaryLane === taskPrimaryLane;
            const gapMinutes = task.startMin - (dep.startMin + dep.duration);
            const bothActive = depPrimaryLane && taskPrimaryLane && !isPassiveOnLane(dep, depPrimaryLane) && !isPassiveOnLane(task, taskPrimaryLane);
            if (sameLane && bothActive && gapMinutes >= 0 && gapMinutes <= 5) continue;

            // Gradient from source color to target color
            const gradId = `dep-grad-${arrowIdx}`;
            const markerId = `dep-arrow-${arrowIdx}`;
            const fromColor = isViolation ? '#ef4444' : dep.color;
            const toColor = isViolation ? '#ef4444' : task.color;
            arrowDefs.push(`<linearGradient id="${gradId}" gradientUnits="userSpaceOnUse" x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}"><stop offset="0%" stop-color="${fromColor}" stop-opacity="0.7"/><stop offset="100%" stop-color="${toColor}" stop-opacity="0.7"/></linearGradient>`);
            arrowDefs.push(`<marker id="${markerId}" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto"><path d="M0,0 L6,2 L0,4" fill="${toColor}" opacity="0.7"/></marker>`);

            const markerEnd = `marker-end="url(#${markerId})"`;

            let path;
            const sameY = Math.abs(fromY - toY) < 2;
            if (sameY) {
              // Same height: straight line
              path = `M${fromX},${fromY} L${toX},${toY}`;
            } else {
              const dir = toY > fromY ? 1 : -1;
              const straightGap = toX - GAP - fromX;

              if (straightGap >= MIN_RUN * 0.5) {
                // Normal: right → down → right into target (3-segment)
                const midX = fromX + straightGap / 2;
                const r = Math.min(RADIUS, Math.abs(fromY - toY) / 2, straightGap / 4);
                path = `M${fromX},${fromY} L${midX - r},${fromY} Q${midX},${fromY} ${midX},${fromY + dir * r} L${midX},${toY - dir * r} Q${midX},${toY} ${midX + r},${toY} L${toX},${toY}`;
              } else {
                // Tight: 5-segment staircase that arrives from the left
                const rightX = Math.max(fromX, toX) + MIN_RUN * 0.3;
                const leftX = Math.min(fromX, toX - GAP) - MIN_RUN * 0.3;
                const midY = (fromY + toY) / 2;
                const halfVert = Math.abs(midY - fromY);
                const bridgeLen = Math.abs(rightX - leftX);
                const r = Math.min(RADIUS, halfVert, bridgeLen > 0 ? bridgeLen / 2 : RADIUS);

                path = `M${fromX},${fromY}` +
                  ` L${rightX - r},${fromY}` +
                  ` Q${rightX},${fromY} ${rightX},${fromY + dir * r}` +
                  ` L${rightX},${midY - dir * r}` +
                  ` Q${rightX},${midY} ${rightX - r},${midY}` +
                  ` L${leftX + r},${midY}` +
                  ` Q${leftX},${midY} ${leftX},${midY + dir * r}` +
                  ` L${leftX},${toY - dir * r}` +
                  ` Q${leftX},${toY} ${leftX + r},${toY}` +
                  ` L${toX},${toY}`;
              }
            }

            svg += `<path d="${path}" fill="none" stroke="url(#${gradId})" stroke-width="1.5" stroke-dasharray="${dashArray}" class="dep-arrow" ${markerEnd}/>`;
            arrowIdx++;
          }
        }
      }

      // Arrow gradient and marker defs
      svg += `<defs>${arrowDefs.join('')}</defs>`;

      // Task blocks (cascaded by sequence index)
      for (let ti = 0; ti < tasks.length; ti++) {
        const task = tasks[ti];
        if (task.startMin === null || !task.assignedLanes) continue;
        for (const subLane of task.assignedLanes) {
          const laneIdx = lanes.indexOf(subLane);
          if (laneIdx === -1) continue;
          const seq = (taskCascade.get(ti) || {})[subLane] || 0;
          const x = LANE_LABEL_WIDTH + (task.startMin - startMinutes) * pixelsPerMinute;
          const passiveCount = passiveCounts[subLane] || 0;
          const passiveSpace = passiveCount > 0 
            ? passiveCount * PASSIVE_BAR_HEIGHT + (passiveCount - 1) * PASSIVE_BAR_GAP + 12
            : 0;
          const laneY = HEADER_HEIGHT + laneYOffsets[laneIdx] + BLOCK_PADDING + passiveSpace;
          const passiveHere = isPassiveOnLane(task, subLane);
          const w = task.duration * pixelsPerMinute;
          const isViolated = violations.some(v =>
            v.to === task || (v.type === 'overlap' && v.from === task)
          );

          if (passiveHere) {
            // Passive tasks: thin colored bars at top of lane
            const y = HEADER_HEIGHT + laneYOffsets[laneIdx] + BLOCK_PADDING + seq * (PASSIVE_BAR_HEIGHT + PASSIVE_BAR_GAP);
            const h = PASSIVE_BAR_HEIGHT;
            svg += `<g class="task-block" data-task-idx="${ti}" data-sublane="${subLane}">`;
            svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="3" fill="${task.color}" opacity="0.45"/>`;
            svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="3" fill="none" stroke="${task.color}" stroke-width="1" stroke-dasharray="3 2" opacity="0.7"/>`;
            if (isViolated) {
              svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="3" fill="none" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="3 2"/>`;
            }
            // Compact label only if bar is wide enough
            const textMaxW = w - 6;
            if (textMaxW > 30) {
              svg += `<clipPath id="clip-${ti}-${laneIdx}-${seq}"><rect x="${x + 3}" y="${y}" width="${textMaxW}" height="${h}"/></clipPath>`;
              svg += `<text x="${x + 4}" y="${y + h / 2 + 0.5}" fill="white" font-size="10" font-weight="500" dominant-baseline="middle" font-family="sans-serif" opacity="0.9" clip-path="url(#clip-${ti}-${laneIdx}-${seq})">${escapeHtml(task.name)}</text>`;
            }
            svg += `</g>`;
          } else {
            // Active tasks: full-height blocks
            const y = laneY + seq * CASCADE_STEP;
            const h = BLOCK_HEIGHT;
            svg += `<g class="task-block" data-task-idx="${ti}" data-sublane="${subLane}">`;
            svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="6" fill="${task.color}" opacity="0.88"/>`;
            if (isViolated) {
              svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="6" fill="none" stroke="#ef4444" stroke-width="2" stroke-dasharray="4 2"/>`;
            }
            // Text label (clipped)
            const textMaxW = w - 8;
            if (textMaxW > 20) {
              svg += `<clipPath id="clip-${ti}-${laneIdx}-${seq}"><rect x="${x + 4}" y="${y}" width="${textMaxW}" height="${h}"/></clipPath>`;
              svg += `<text x="${x + 6}" y="${y + h / 2 + 1}" fill="white" font-size="12" font-weight="500" dominant-baseline="middle" font-family="sans-serif" clip-path="url(#clip-${ti}-${laneIdx}-${seq})">${escapeHtml(task.name)}</text>`;
            }
            svg += `</g>`;
          }
        }
      }

      // Current time line
      if (showNowCheck.checked) {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        if (nowMin >= startMinutes && nowMin <= endMinutes) {
          const x = LANE_LABEL_WIDTH + (nowMin - startMinutes) * pixelsPerMinute;
          svg += `<line x1="${x}" y1="${HEADER_HEIGHT}" x2="${x}" y2="${chartHeight}" stroke="#f43f5e" stroke-width="2" class="now-line"/>`;
          svg += `<text x="${x}" y="${HEADER_HEIGHT - 2}" fill="#f43f5e" font-size="9" text-anchor="middle" font-family="monospace">NOW</text>`;
        }
      }

      svg += '</svg>';
      ganttContainer.innerHTML = svg;

      // Attach drag handlers
      attachDragHandlers();
    }

    // ── Drag ──
    function attachDragHandlers() {
      const svgEl = document.getElementById('gantt-svg');
      if (!svgEl) return;

      const blocks = svgEl.querySelectorAll('.task-block');
      blocks.forEach(block => {
        block.addEventListener('mousedown', (e) => {
          if (e.button === 0) onDragStart(e); // left click
          else if (e.button === 2) onRightClick(e, block); // right click
        });
        block.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          onRightClick(e, block);
        });
      });

      // Tooltip on hover
      blocks.forEach(block => {
        block.addEventListener('mouseenter', (e) => {
          const idx = parseInt(block.dataset.taskIdx);
          const task = tasks[idx];
          if (!task) return;
          const taskViolations = getViolations().filter(v => v.to === task || v.from === task);
          let html = `<strong>${escapeHtml(task.name)}</strong><br/>`;
          html += `${minutesToTime(task.startMin)} → ${minutesToTime(task.startMin + task.duration)} (${formatDuration(task.duration)})<br/>`;
          const reqStrs = task.laneReqs.map(req => {
            let label;
            if (req.pinnedLanes) label = req.pinnedLanes.join(', ');
            else label = req.count === 1 ? req.groupName : `${req.groupName}*${req.count}`;
            return req.passive ? label + '(P)' : label;
          });
          html += `Needs: ${reqStrs.join(', ')}`;
          const passiveLanes = task.laneReqs.filter(r => r.passive).map(r => r.groupName);
          if (passiveLanes.length) html += `<br/><span style="color:#94a3b8; font-size:10px;">Passive on: ${passiveLanes.join(', ')}</span>`;
          if (task.assignedLanes && task.assignedLanes.length > 0) {
            html += `<br/>Assigned to: ${task.assignedLanes.join(', ')}`;
          }
          if (task.deps.length) html += `<br/>After: ${task.deps.join(', ')}`;
          const depViolations = taskViolations.filter(v => v.type === 'dependency');
          const overlapViolations = taskViolations.filter(v => v.type === 'overlap');
          if (depViolations.length) html += `<br/><span style="color:#ef4444">⚠ Dependency violation</span>`;
          if (overlapViolations.length) {
            const others = overlapViolations.map(v => v.from === task ? v.to.name : v.from.name);
            html += `<br/><span style="color:#ef4444">⚠ Overlaps with ${others.map(n => escapeHtml(n)).join(', ')}</span>`;
          }
          tooltipEl.innerHTML = html;
          tooltipEl.classList.remove('hidden');
        });
        block.addEventListener('mousemove', (e) => {
          tooltipEl.style.left = (e.clientX + 12) + 'px';
          tooltipEl.style.top = (e.clientY - 10) + 'px';
        });
        block.addEventListener('mouseleave', () => {
          tooltipEl.classList.add('hidden');
        });
      });

      svgEl.addEventListener('mousemove', onDragMove);
      svgEl.addEventListener('mouseup', onDragEnd);
      svgEl.addEventListener('mouseleave', onDragEnd);
    }

    // ── Pan (drag empty space to scroll) ──
    function onPanStart(e) {
      // Don't start panning if clicking on a task block or if already dragging a task
      if (dragState) return;
      
      // Check if clicking on a task block or its children
      const clickedElement = e.target;
      if (clickedElement.closest('.task-block') || clickedElement.classList.contains('task-block')) {
        return;
      }
      
      // Only pan with left mouse button
      if (e.button !== 0) return;
      
      panState = {
        startX: e.clientX,
        startY: e.clientY,
        startScrollLeft: ganttContainer.scrollLeft,
        startScrollTop: ganttContainer.scrollTop
      };
      
      ganttContainer.style.cursor = 'grabbing';
      e.preventDefault();
    }

    function onPanMove(e) {
      if (!panState) return;
      
      const deltaX = panState.startX - e.clientX;
      const deltaY = panState.startY - e.clientY;
      
      ganttContainer.scrollLeft = panState.startScrollLeft + deltaX;
      ganttContainer.scrollTop = panState.startScrollTop + deltaY;
    }

    function onPanEnd(e) {
      if (!panState) return;
      
      panState = null;
      ganttContainer.style.cursor = '';
    }

    // Attach pan handlers to gantt container
    ganttContainer.addEventListener('mousedown', onPanStart);
    ganttContainer.addEventListener('mousemove', onPanMove);
    ganttContainer.addEventListener('mouseup', onPanEnd);
    ganttContainer.addEventListener('mouseleave', onPanEnd);

    // ── Dependency group helper ──
    // Returns the set of task names connected to the given task via dependency relationships
    // (both upstream and downstream, transitively)
    function getDependencyGroup(taskName) {
      const group = new Set();
      const queue = [taskName];
      while (queue.length > 0) {
        const current = queue.shift();
        const currentTask = tasks.find(t => t.name === current);
        if (!currentTask) continue;
        // Upstream: tasks this one depends on
        for (const depName of currentTask.deps) {
          if (!group.has(depName) && depName !== taskName) {
            group.add(depName);
            queue.push(depName);
          }
        }
        // Downstream: tasks that depend on this one
        for (const t of tasks) {
          if (t.deps.includes(current) && !group.has(t.name) && t.name !== taskName) {
            group.add(t.name);
            queue.push(t.name);
          }
        }
      }
      return group;
    }

    function onDragStart(e) {
      e.preventDefault();
      e.stopPropagation(); // Prevent pan from starting
      if (panState) panState = null; // Stop any active pan
      
      const block = e.currentTarget;
      const idx = parseInt(block.dataset.taskIdx);
      const task = tasks[idx];

      const svgEl = document.getElementById('gantt-svg');
      const svgRect = svgEl.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left + ganttContainer.scrollLeft;
      const taskX = LANE_LABEL_WIDTH + (task.startMin - startMinutes) * pixelsPerMinute;

      const isGroupDrag = e.metaKey;
      dragState = {
        taskIdx: idx,
        offsetX: mouseX - taskX,
        origStartMin: task.startMin,
        groupDrag: isGroupDrag,
        groupOffsets: null   // Map<taskIdx, deltaFromDragTask> for group members
      };

      if (isGroupDrag) {
        const group = getDependencyGroup(task.name);
        const offsets = new Map();
        for (let i = 0; i < tasks.length; i++) {
          if (group.has(tasks[i].name)) {
            offsets.set(i, tasks[i].startMin - task.startMin);
          }
        }
        dragState.groupOffsets = offsets;
      }

      // Mark all blocks for this task (and group members)
      document.querySelectorAll(`.task-block[data-task-idx="${idx}"]`).forEach(b => b.classList.add('dragging'));
      if (dragState.groupDrag && dragState.groupOffsets) {
        for (const [tIdx] of dragState.groupOffsets) {
          document.querySelectorAll(`.task-block[data-task-idx="${tIdx}"]`).forEach(b => b.classList.add('dragging'));
        }
      }
      tooltipEl.classList.add('hidden');
    }

    function onDragMove(e) {
      if (!dragState) return;
      e.stopPropagation(); // Prevent pan when dragging tasks
      const svgEl = document.getElementById('gantt-svg');
      const svgRect = svgEl.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left + ganttContainer.scrollLeft;

      const rawMin = startMinutes + (mouseX - LANE_LABEL_WIDTH - dragState.offsetX) / pixelsPerMinute;
      const dragTask = tasks[dragState.taskIdx];
      let snapped;
      if (shiftHeld) {
        snapped = Math.round(rawMin);
      } else {
        // Grid snap at 5-min intervals
        snapped = Math.round(rawMin / 5) * 5;

        // Magnetic snap: if a neighbor edge is closer than 5 min, prefer it
        // Collect all start/end edges from other tasks sharing any sub-lane (excluding group members)
        const groupIndices = dragState.groupDrag && dragState.groupOffsets ? new Set(dragState.groupOffsets.keys()) : new Set();
        const edges = [];
        for (let ti = 0; ti < tasks.length; ti++) {
          const t = tasks[ti];
          if (t === dragTask || t.startMin === null || !t.assignedLanes) continue;
          if (groupIndices.has(ti)) continue;  // Skip group members
          // Only consider tasks that share at least one sub-lane
          const shares = dragTask.assignedLanes && dragTask.assignedLanes.some(l => t.assignedLanes.includes(l));
          if (!shares) continue;
          edges.push(t.startMin);                 // neighbor start
          edges.push(t.startMin + t.duration);    // neighbor end
        }
        // For each edge, check snap to: dragTask.start == edge, or dragTask.end == edge
        let bestDist = 5; // only snap if strictly closer than the grid size
        for (const edge of edges) {
          // Snap dragged task's start to edge
          const distStart = Math.abs(rawMin - edge);
          if (distStart < bestDist) {
            bestDist = distStart;
            snapped = edge;
          }
          // Snap dragged task's end to edge (so startMin = edge - duration)
          const alignEnd = edge - dragTask.duration;
          const distEnd = Math.abs(rawMin - alignEnd);
          if (distEnd < bestDist) {
            bestDist = distEnd;
            snapped = alignEnd;
          }
        }
      }
      // Compute bounds: keep main task and all group members within the timeline
      let minBound = startMinutes;
      let maxBound = endMinutes - dragTask.duration;
      if (dragState.groupDrag && dragState.groupOffsets) {
        for (const [tIdx, offset] of dragState.groupOffsets) {
          const t = tasks[tIdx];
          // Group member position = snapped + offset
          // Need: snapped + offset >= startMinutes
          minBound = Math.max(minBound, startMinutes - offset);
          // Need: snapped + offset + t.duration <= endMinutes
          maxBound = Math.min(maxBound, endMinutes - t.duration - offset);
        }
      }
      snapped = Math.max(minBound, Math.min(snapped, maxBound));

      dragTask.startMin = snapped;

      // Move group members by maintaining their offset from the dragged task
      if (dragState.groupDrag && dragState.groupOffsets) {
        for (const [tIdx, offset] of dragState.groupOffsets) {
          tasks[tIdx].startMin = snapped + offset;
        }
      }

      drawGantt();

      // Re-mark dragging visuals
      document.querySelectorAll(`.task-block[data-task-idx="${dragState.taskIdx}"]`).forEach(b => b.classList.add('dragging'));
      if (dragState.groupDrag && dragState.groupOffsets) {
        for (const [tIdx] of dragState.groupOffsets) {
          document.querySelectorAll(`.task-block[data-task-idx="${tIdx}"]`).forEach(b => b.classList.add('dragging'));
        }
      }
    }

    function onDragEnd(e) {
      if (!dragState) return;
      const task = tasks[dragState.taskIdx];

      // Collect all moved task indices (main + group dependents)
      const movedIndices = new Set([dragState.taskIdx]);
      if (dragState.groupDrag && dragState.groupOffsets) {
        for (const [tIdx] of dragState.groupOffsets) movedIndices.add(tIdx);
      }
      const movedTasks = new Set([...movedIndices].map(i => tasks[i]));

      // Check violations for all moved tasks (dependency + overlap)
      const violations = getViolations().filter(v => movedTasks.has(v.to) || movedTasks.has(v.from));

      for (const mIdx of movedIndices) {
        if (violations.length > 0) {
          document.querySelectorAll(`.task-block[data-task-idx="${mIdx}"]`).forEach(b => {
            b.classList.add('error');
            b.classList.remove('dragging');
          });
        } else {
          document.querySelectorAll(`.task-block[data-task-idx="${mIdx}"]`).forEach(b => {
            b.classList.remove('dragging');
          });
        }
      }

      dragState = null;
      drawGantt();
      syncGanttToDsl();
    }

    // ── Context menu for sub-lane reassignment ──
    function hideContextMenu() {
      contextMenuEl.classList.add('hidden');
      contextMenuEl.innerHTML = '';
    }

    function onRightClick(e, block) {
      e.preventDefault();
      e.stopPropagation();
      
      const idx = parseInt(block.dataset.taskIdx);
      const task = tasks[idx];
      if (!task || !task.assignedLanes || task.assignedLanes.length === 0) return;

      // Find which group requirement this sub-lane belongs to
      const currentSubLane = block.dataset.sublane;
      let reqIdx = -1;
      let groupName = null;
      for (let i = 0; i < task.laneReqs.length; i++) {
        const req = task.laneReqs[i];
        const subLanes = getSubLanesForGroup(req.groupName);
        if (subLanes.includes(currentSubLane)) {
          reqIdx = i;
          groupName = req.groupName;
          break;
        }
      }
      if (!groupName || reqIdx === -1) return;

      const req = task.laneReqs[reqIdx];
      
      // For multi-lane requirements, don't show context menu (too complex to reassign all at once)
      if (req.count > 1) return;

      // Get all sub-lanes for this group
      const subLanes = getSubLanesForGroup(groupName);
      if (subLanes.length <= 1) return; // No point showing menu if only one option

      // Build menu
      contextMenuEl.innerHTML = '';
      subLanes.forEach(subLane => {
        const item = document.createElement('div');
        item.className = 'context-menu-item' + (subLane === currentSubLane ? ' active' : '');
        item.textContent = subLane;
        item.addEventListener('click', () => {
          // Reassign task to this sub-lane (only works for single-lane requirements)
          if (task.assignedLanes && reqIdx < task.assignedLanes.length) {
            task.assignedLanes[reqIdx] = subLane;
            hideContextMenu();
            drawGantt();
            syncGanttToDsl();
          }
        });
        contextMenuEl.appendChild(item);
      });

      // Position menu
      contextMenuEl.style.left = e.clientX + 'px';
      contextMenuEl.style.top = e.clientY + 'px';
      contextMenuEl.classList.remove('hidden');
    }

    // Hide context menu on click outside or Escape
    document.addEventListener('click', hideContextMenu);
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideContextMenu();
    });

    // ── Parse error display ──
    const parseErrorsContainer = document.getElementById('parse-errors');
    function showParseErrors(errors) {
      const inner = parseErrorsContainer.querySelector('div');
      if (errors.length === 0) {
        parseErrorsContainer.classList.add('hidden');
        inner.innerHTML = '';
        return;
      }
      inner.innerHTML = errors.map(e => `<div>• ${escapeHtml(e)}</div>`).join('');
      parseErrorsContainer.classList.remove('hidden');
    }

    // ── Helpers ──
    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // ── Copy LLM prompt ──
    document.getElementById('btn-copy-prompt').addEventListener('click', () => {
      const prompt = `I need you to generate a .gantt file for a Gantt chart tool. Output the file in the following exact plain-text format:

VERSION 1

START HH:MM
END HH:MM

LANES
LaneName: count
LaneName2
...

TASKS
Task Name | Duration | Lane(s) | Color | Dependencies | @Start
...

FORMAT RULES:
- VERSION is always 1
- START / END define the visible time window in 24h HH:MM format
- LANES section: one lane per line. "Name: count" creates multiple sub-lanes (e.g. "Person: 2" creates "Person 1" and "Person 2"). Omit count for a single lane.
- TASKS section: one task per line, fields pipe-separated:
  - Name: unique task name
  - Duration: e.g. 15m, 1h, 1h30m, 90m
  - Lane(s): comma-separated lane names. Use *count for multiple sub-lanes (e.g. "Person*2"). Append (P) to mark as passive on that lane (e.g. "Person(P)") — passive lanes don't block scheduling.
  - Color: hex color like #3b82f6 (optional, defaults to blue)
  - Dependencies: "after Task A, Task B" (optional)
  - @Start: pin to a specific time, e.g. @08:30 (optional — omit to let auto-schedule decide)

EXAMPLE:

VERSION 1

START 08:00
END 14:00

LANES
Person: 2
Oven

TASKS
Chop vegetables | 15m | Person | #3b82f6
Boil water | 10m | Person | #ef4444
Season chicken | 10m | Person | #a855f7 | after Chop vegetables
Cook pasta | 20m | Person | #f59e0b | after Boil water
Bake chicken | 45m | Oven | #a855f7 | after Season chicken
Plate meal | 10m | Person*2, Oven | #10b981 | after Cook pasta, Bake chicken
Music playing | 60m | Person(P) | #6b7280

Please generate a .gantt file for: [DESCRIBE YOUR SCENARIO HERE]`;

      navigator.clipboard.writeText(prompt).then(() => {
        const btn = document.getElementById('btn-copy-prompt');
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        btn.classList.add('bg-green-700');
        setTimeout(() => { btn.textContent = orig; btn.classList.remove('bg-green-700'); }, 1500);
      });
    });

    // ── Export dropdown ──
    const exportMenu = document.getElementById('export-menu');
    const exportBtn = document.getElementById('btn-export');
    let exportMenuOpen = false;

    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportMenuOpen = !exportMenuOpen;
      exportMenu.classList.toggle('hidden', !exportMenuOpen);
    });

    function buildGanttFile() {
      const exportedTasks = exportTasks();
      return `VERSION 1

START ${startTimeInput.value}
END ${endTimeInput.value}

LANES
${lanesInput.value}

TASKS
${exportedTasks}`;
    }

    document.getElementById('export-copy').addEventListener('click', () => {
      if (!tasks.length) return;
      const text = buildGanttFile();
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('export-copy');
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = orig; }, 1500);
      });
      exportMenuOpen = false;
      exportMenu.classList.add('hidden');
    });

    document.getElementById('export-save').addEventListener('click', () => {
      if (!tasks.length) return;
      const content = buildGanttFile();
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'gantt.gantt';
      a.click();
      URL.revokeObjectURL(url);
      exportMenuOpen = false;
      exportMenu.classList.add('hidden');
    });

    // Close export menu on click outside
    document.addEventListener('click', (e) => {
      if (exportMenuOpen && !exportBtn.contains(e.target) && !exportMenu.contains(e.target)) {
        exportMenuOpen = false;
        exportMenu.classList.add('hidden');
      }
    });

    // ── Import button ──
    const fileInput = document.getElementById('file-input');
    document.getElementById('btn-import').addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        // Parse .gantt format
        const lines = content.split('\n');
        let version = null;
        let start = null;
        let end = null;
        let inLanes = false;
        let inTasks = false;
        const laneLines = [];
        const taskLines = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          if (line.startsWith('VERSION ')) {
            version = parseInt(line.slice(8));
          } else if (line.startsWith('START ')) {
            start = line.slice(6);
          } else if (line.startsWith('END ')) {
            end = line.slice(4);
          } else if (line === 'LANES') {
            inLanes = true;
            inTasks = false;
          } else if (line === 'TASKS') {
            inLanes = false;
            inTasks = true;
          } else if (inLanes) {
            laneLines.push(line);
          } else if (inTasks) {
            taskLines.push(line);
          }
        }

        suppressSync = true;
        if (start) startTimeInput.value = start;
        if (end) endTimeInput.value = end;
        if (laneLines.length) lanesInput.value = laneLines.join('\n');
        if (taskLines.length) tasksInput.value = taskLines.join('\n');
        suppressSync = false;
        onDslChange();
      };
      reader.readAsText(file);
      e.target.value = ''; // Reset file input
    });

    // ── Render button (shown only when input needs auto-scheduling) ──
    document.getElementById('btn-render').addEventListener('click', () => {
      const parsed = parseLaneGroups();
      laneGroups = parsed.groups;
      lanes = parsed.flatLanes;
      const parseResult = parseTasks(lanes);
      tasks = parseResult.tasks;
      showParseErrors(parseResult.errors);
      if (parseResult.errors.length > 0) return;

      startMinutes = timeToMinutes(startTimeInput.value);
      endMinutes = timeToMinutes(endTimeInput.value);
      if (endMinutes <= startMinutes) endMinutes = startMinutes + 360;

      // Auto-schedule unpinned tasks
      autoSchedule();

      const totalMinutes = endMinutes - startMinutes;
      const availableWidth = ganttContainer.clientWidth - LANE_LABEL_WIDTH - 20;
      pixelsPerMinute = Math.max(2, availableWidth / totalMinutes);
      drawGantt();
      syncGanttToDsl(); // Write back the now-pinned DSL
      document.getElementById('btn-render').classList.add('hidden');
    });

    showNowCheck.addEventListener('change', () => { if (tasks.length) drawGantt(); });
    showDepsCheck.addEventListener('change', () => { if (tasks.length) drawGantt(); });

    // ── Zoom with Ctrl+scroll ──
    ganttContainer.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const oldPpm = pixelsPerMinute;
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        pixelsPerMinute = Math.max(1, Math.min(20, pixelsPerMinute * delta));
        if (tasks.length) {
          // Keep mouse position stable
          const rect = ganttContainer.getBoundingClientRect();
          const mouseX = e.clientX - rect.left + ganttContainer.scrollLeft;
          const ratio = pixelsPerMinute / oldPpm;
          ganttContainer.scrollLeft = mouseX * ratio - (e.clientX - rect.left);
          drawGantt();
        }
      }
    }, { passive: false });

    // ── Initial render with example data ──
    render();
    syncGanttToDsl(); // Write back the pinned DSL so everything becomes fully pinned
  </script>
</body>
</html>
